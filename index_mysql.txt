1  b-tree 索引：
节点存[key,data]和指针  叶节点的指针为null
先从根节点进行二分查找，如果找到就返回对应节点的data。
如果没有找到，则对对应的区间的指针指向的节点进行递归查找，
直到找到节点或者null指针

2  b+tree 索引：
节点存key和指针  叶子存 data和key 不存指针


3 myisam 索引：
只存储数据记录的地址
主键索引和其他索引的存储方式没有区别

4 innodb 索引
索引文件就是数据文件
其他索引都引用主键作为data域，所以其他索引要查找两次，找其他索引确定主键，通过主键找数据


5 最左前缀原理与优化
全值匹配我最爱，最左前缀要遵守；
带头大哥不能死，中间兄弟不能断；
索引列上不计算，范围之后全失效；
LIKE百分写最右，覆盖索引不写 *；
不等空值还有or，索引失效要少用；
字符单引不可丢，SQL高级也不难 ；


6  建索引的条件：
经常使用列
选择度高，宽度小
记录比较少不建
索引的选择性低不建（这个字段的出现情况/记录总数）

前缀索引可以解决长度和选择性，但是不能用于排序和分组

7  影响数据库查询的几个因素：
SQL查询速度
网卡流量：减少从服务器的数量，进行分级缓存，避免select *，分离业务和服务器网络
服务器硬件
磁盘io：更快的磁盘设备，调整计划任务，做好磁盘维护

qps 每秒查询率
tps 事务数


8 大表
    慢查询
    建立索引会锁表或者造成主从延迟
    修改表结构需要长时间的锁表
    分表后会带来大量的查询问题
大表处理：
分库分表
数据修改：分批处理
结构修改：
主从复制
添加新表-》老数据导入-》老表触发器同步新数据-》老表新表重命名-》删除老表
优化：
最优的SQL和索引
缓存
主从复制，读写分离
分区表
垂直拆分
水平拆分

9 事务
一致性
原子性
隔离性
持久性

隔离等级：未提交读  已提交读  可重复读 可串行化
修改隔离级别：set session tx_isolation='read-committed';

大事务 ： 锁定数据太多，出错后回滚时间长，执行时间长
避免大事务：分批处理数据，移除不必要的select操作，保证事务中只有必要的写操作



10 影响性能的几个方面
服务器硬件
服务器系统-系统参数优化
存储引擎 myisam 不支持事务，表级锁 innodb支持事务，支持行级锁。事务
数据库参数配置
数据库结构设计和SQL语句（推荐使用独立的表空间 5.6默认）

11 数据库结构优化：
    减少数据冗余 尽量能通过现有字段计算出来的值就不要另外写字段
    尽量避免数据维护中出现更新插入和删除异常
    节约数据存储空间
    提高查询效率

12 三大范式
    原子性
    唯一性
    冗余性（空间换时间）

14 表设计：范式化：可以尽量减少数据冗余 但是查询的时候需要关联多张表，不利于索引优化
          反范式化：可以减少表之间的关联，利于索引优化 但是存在数据冗余以及数据维护异常

15 字段的选择：
数字 》 日期 》 二进制 》 字符
空间小的数据类型
尽量not null

16 如何选择主键：
主键要尽可能的小
主键要顺序增长
主键和业务主键可以不是一个

17 索引优化：
b-tree:适合范围查找
最左原则
not in 和不等无法使用索引
范围查询后的索引会失效

hash:精确匹配
必须二次查找
无法排序
不支持范围查询
存在hash冲突，不适合重复性很高的列

18 索引的区别：
主键索引：primary key 不允许有空值
唯一索引：unique 值必须唯一，但允许有空值
普通索引：index
全文索引：fulltext myisam表
组合索引：index mmm(m,m1,m2)

19  索引的缺陷：
索引会增加写成本
太多的索引会增加查询优化器的选择时间


20 索引优化策略：
索引不要太多
索引列上不要使用表达式和函数
索引的选择性是不重复的值和表记录数的比值
宽度小的列
经常被使用
text varchar 建立前缀索引不能排序

联合索引策略
覆盖索引策略：减少io，避免二次回表查询
什么时候不能用覆盖索引：
存储引擎不支持
select *
使用双%的like

索引优化查询：
删除重复索引和冗余索引
group BY 先排序后分组
order by 的顺序和索引一致
无法使用索引时增大：max_length_for_sort_data,sort_buffer_size
如果最左边索引使用范围查询，则索引失效
where的执行顺序高于having


21 explain 查询计划
ID :包含一组数字，表示查询中执行的顺序 ID越大优先级越高
select_type :a. SIMPLE：查询中不包含子查询或者UNION
             b. 查询中若包含任何复杂的子部分，最外层查询则被标记为：PRIMARY
             c. 在SELECT或WHERE列表中包含了子查询，该子查询被标记为：SUBQUERY
             d. 在FROM列表中包含的子查询被标记为：DERIVED（衍生）用来表示包含在from子句中的子查询的select，mysql会递归执行并将结果放到一个临时表中。服务器内部称为"派生表"，因为该临时表是从子查询中派生出来的
             e. 若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中，外层SELECT将被标记为：DERIVED
             f. 从UNION表获取结果的SELECT被标记为：UNION RESULT
type：访问类型：ALL 遍历全表
              index 只遍历索引树
              range 索引范围扫描
              ref 使用非唯一索引或者唯一索引的前缀扫描
              eq_ref 使用唯一索引
              const/system 查询结果转换为一个常量时
              null 不用查表或者索引
possible_key :列出可能使用的索引
key：实际使用的索引
key_len:索引的长度
ref：哪些列被用来查找值
rows：查询的行数
extra:using where ：通过索引查询
      using index：直接访问索引就能获取到数据


22 SQL查询过程：
发送SQL语句
查询缓存，如果有缓存的话直接返回缓存，缓存会加锁，不建议使用
SQL解析，预处理，再由优化器生成对应的查询计划
执行查询，调用存储引擎获取数据
返回结果

建议关闭查询缓存，缓存更新会加锁
query_cache_type off
query_cache_size 0


























































