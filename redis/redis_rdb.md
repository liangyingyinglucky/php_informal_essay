# redis持久化

## Redis高可用方案

redis主从复制
redis哨兵机制
redis集群

这些高可用方案的基础就是持久化。

## Redis持久化概述

redis持久化：为了避免进程退出导致数据永久丢失，定期将Redis的数据备份到磁盘上，下次启动后可从持久化文件恢复数据。

Redis持久化方式

RDB：将当前内存中的数据保存到磁盘上，默认的持久化方式

AOF：将每次的写命令保存到磁盘上，实时性更好，数据丢失少，热门的持久化方式

RDB持久化

RDB持久化：将Redis某一时刻的内存数据保存到硬盘的文件当中，默认保存的文件名：dump.rdb

开启持久化的方式：

手动执行 ：save/bgsavesave会阻塞Redis服务器进程，因为Redis服务器是单进程单线程的，在当前进程内执行save命令，客户端发送的其他命令必须等save命令执行完毕后才能执行，这段时间Redis服务器是不能处理任何请求，不推荐使用。bgsave，是fork一个子进程，由子进程完成持久化动作，而父进程仍然可以执行其他请求，但fork子进程这个动作是同步的，会阻塞服务器，因此bgsave也会有阻塞处理请求的情况发生。


自动执行：在配置项文件中配置: save m n
##  900s内至少达到一条写命令
save 900 1
##  300s内至少达至10条写命令
save 300 10
##  60s内至少达到10000条写命令
save 60 10000
在Redis服务器中有一个serverCron函数来定时执行，默认每100ms执行一次，dirty和lastsave共同决定。
执行shutdown命令时，自动执行rdb持久化
主从复制时，从节点执行全量复制操作，主节点会执行bgsave命令

## RDB文件的生成过程

生成临时rdb文件，写入数据
数据写入完成后，用临时rdb文件替换掉正式rdb文件
Redis 用新 RDB 文件替换原来的 RDB 文件
删除旧的 RDB 文件。

## AOF持久化

AOF持久化：记录客户端对服务器的每一次写操作命令，并将这些写操作以Redis协议追加保存到以后缀为aof文件末尾，Redis服务器重启时，会加载并运行aof文件的命令来恢复数据。

开启AOF持久化方式

##  开启aof机制
appendonly yes

##  aof文件名
appendfilename "appendonly.aof"

##  写入策略,always表示每个写操作都保存到aof文件中,也可以是everysec或no
appendfsync everysec

##  默认不重写aof文件
no-appendfsync-on-rewrite no

执行流程

命令追加：将写命令写入到缓冲区aof_buf中

文件写入和文件同步：根据不同的同步策略将aof_buf内容写入到磁盘上同步策略：always、everysec、noalways：同步持久化，每次发生数据变更时，立即记录到磁盘（慢，安全）everysec：每秒同步一次（默认值，很快，但可能会丢失1秒以内的数据）no：不主动同步，由操作系统决定多久同步数据（快，不安全）

文件重写：定期重写AOF文件，达到压缩的目的AOF是以日志追加的方式将命令字符串协议保存在AOF文件中，随着我们使用redis的时间越长，最redis的操作越多，这个AOF文件会越来越大，如果不做处理，总有会撑爆磁盘，所以就出现了重写，重写就是专门给AOF文件廋身的。重写思想：根据当前内存中的数据，生成新的AOF文件，然后去替换旧的AOF文件。重写为什么可以达到瘦身的目的：1. 过期的数据不再写入文件；2. 无效的命令不再写入文件，如先添加后删除；3. 多个命令可以合并成一条。触发机制：手动触发、自动触发手动触发：执行bgrewriteaof命令自动触发：当AOF文件增长到一定大小的时候Redis能够调用 bgrewriteaof对日志文件进行重写 。当auto-aof-rewrite-min-size（默认64M）和auto-aof-rewrite-percentage（默认100）两个参数同时满足时，才会自动触发AOF重写，即bgrewriteaof操作。

## 总结：

既然有了RDB，为什么还要AOF？

优化数据丢失，RDB会丢失最后一次快照后的数据，而AOF丢失不会超过2秒的数据

如果既有RDB也有AOF，以谁为准？

当AOF开启时，优先载入AOF文件来恢复数据；当AOF关闭时，才会从RDB文件恢复数据
AOF和RDB优劣rdb 适合大规模的数据恢复，对数据完整性和一致性不高 ，在一定时间内做一次备份，如果redis意外宕机，会丢失最后一个快照之后的数据aof根据配置项而定，如果默认配置项，不会丢失超过2秒的数据
